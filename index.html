<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Crypto BB Scanner</title>
    <style>
        /* Existing CSS remains unchanged, adding WebSocket status style */
        .ws-status {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            font-weight: 500;
        }
        .ws-status.connected {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid rgba(40, 167, 69, 0.5);
        }
        .ws-status.disconnected {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid rgba(220, 53, 69, 0.5);
        }
        .ws-status.connecting {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" role="banner">
            <h1>ðŸš€ Bybit Crypto BB Scanner</h1>
            <p>Real-time signals with customizable indicators for spot and futures markets</p>
        </div>

        <div class="controls" role="region" aria-label="Scanner controls">
            <!-- Existing controls HTML unchanged -->
            <!-- Add WebSocket status indicator -->
            <div id="wsStatus" class="ws-status disconnected" role="alert">
                WebSocket: Disconnected
            </div>
            <!-- Rest of the controls HTML remains the same -->
        </div>

        <div id="status" class="status" role="alert" style="display: none;"></div>

        <div class="stats" id="stats" style="display: none;" role="region" aria-label="Scanning statistics">
            <!-- Existing stats HTML unchanged -->
        </div>

        <div class="results" id="results" role="region" aria-label="Current trading signals"></div>

        <div class="history-section" id="history" role="region" aria-label="Historical trading signals">
            <!-- Existing history HTML unchanged -->
        </div>
    </div>

    <script>
        let isScanning = false;
        let ws = null;
        let wsPingInterval = null;
        let signalHistory = JSON.parse(localStorage.getItem('signalHistory')) || [];
        let marketDataCache = null;
        let cacheTimestamp = 0;
        const CACHE_DURATION = 60 * 1000;
        const klineData = new Map(); // Store kline data for each symbol and timeframe

        // WebSocket Connection Management
        function connectWebSocket(marketType, intervals) {
            if (ws) ws.close();
            const wsUrl = marketType === 'spot'
                ? 'wss://stream.bybit.com/v5/public/spot'
                : 'wss://stream.bybit.com/v5/public/linear';
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                updateWebSocketStatus('WebSocket: Connected', 'connected');
                console.log('WebSocket connected');

                // Subscribe to ticker data for all USDT pairs
                fetchMarketData(marketType).then(tickers => {
                    const symbols = tickers.map(t => t.symbol);
                    const tickerSub = {
                        op: 'subscribe',
                        args: symbols.map(symbol => `tickers.${symbol}`)
                    };
                    ws.send(JSON.stringify(tickerSub));

                    // Subscribe to kline data for selected intervals
                    intervals.forEach(interval => {
                        symbols.forEach(symbol => {
                            const klineSub = {
                                op: 'subscribe',
                                args: [`kline.${interval}.${symbol}`]
                            };
                            ws.send(JSON.stringify(klineSub));
                        });
                    });

                    // Keep connection alive with ping
                    wsPingInterval = setInterval(() => {
                        ws.send(JSON.stringify({ op: 'ping' }));
                    }, 30000);
                });
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'snapshot' || data.type === 'delta') {
                    if (data.topic.startsWith('kline')) {
                        handleKlineUpdate(data, marketType, intervals);
                    } else if (data.topic.startsWith('tickers')) {
                        handleTickerUpdate(data);
                    }
                } else if (data.op === 'ping') {
                    console.log('Pong received');
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateWebSocketStatus('WebSocket: Error', 'disconnected');
            };

            ws.onclose = () => {
                updateWebSocketStatus('WebSocket: Disconnected', 'disconnected');
                if (isScanning) {
                    setTimeout(() => connectWebSocket(marketType, intervals), 5000);
                }
                if (wsPingInterval) clearInterval(wsPingInterval);
            };
        }

        function updateWebSocketStatus(message, status) {
            const wsStatusEl = document.getElementById('wsStatus');
            wsStatusEl.textContent = message;
            wsStatusEl.className = `ws-status ${status}`;
            wsStatusEl.setAttribute('aria-live', 'polite');
        }

        // Handle Kline Data Updates
        function handleKlineUpdate(data, marketType, intervals) {
            const [_, interval, symbol] = data.topic.split('.');
            if (!klineData.has(symbol)) klineData.set(symbol, new Map());
            const symbolKlines = klineData.get(symbol);
            if (!symbolKlines.has(interval)) symbolKlines.set(interval, []);

            const kline = data.data[0];
            const klineEntry = [
                parseInt(kline.start),
                parseFloat(kline.open),
                parseFloat(kline.high),
                parseFloat(kline.low),
                parseFloat(kline.close),
                parseFloat(kline.volume),
                parseInt(kline.end)
            ];

            const klines = symbolKlines.get(interval);
            const index = klines.findIndex(k => k[0] === klineEntry[0]);
            if (index >= 0) {
                klines[index] = klineEntry;
            } else {
                klines.push(klineEntry);
                if (klines.length > 200) klines.shift();
            }

            // Trigger signal generation for this symbol and interval
            if (isScanning) {
                processSignal(symbol, interval, marketType, intervals);
            }
        }

        // Handle Ticker Updates
        function handleTickerUpdate(data) {
            const ticker = data.data;
            marketDataCache = marketDataCache || [];
            const index = marketDataCache.findIndex(t => t.symbol === ticker.symbol);
            if (index >= 0) {
                marketDataCache[index] = ticker;
            } else {
                marketDataCache.push(ticker);
            }
        }

        // Existing Helper Functions (unchanged)
        function calculateSMA(prices, period) {
            if (prices.length < period) return null;
            return prices.slice(-period).reduce((sum, price) => sum + price, 0) / period;
        }

        function calculateEMA(prices, period) {
            if (prices.length < period) return null;
            const k = 2 / (period + 1);
            let ema = prices[0];
            for (let i = 1; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
            }
            return ema;
        }

        // Existing Indicator Calculations (unchanged)
        function calculateBB(prices, period, stdDev, marginPercent) {
            if (prices.length < period) return null;
            const sma = calculateSMA(prices, period);
            const variance = prices.slice(-period).reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
            const standardDeviation = Math.sqrt(variance);
            const margin = marginPercent / 100;
            return {
                middle: sma,
                upper: sma + (standardDeviation * stdDev) * (1 + margin),
                lower: sma - (standardDeviation * stdDev) * (1 + margin),
                bandwidth: (sma + (standardDeviation * stdDev) - (sma - (standardDeviation * stdDev))) / sma
            };
        }

        // ... (Other indicator calculations remain unchanged: calculateRSI, calculateMACD, calculateKDJ, calculateSAR, calculateFibonacci, detectCandlestickPatterns, detectBBSqueeze, calculateIchimoku, calculateDonchian, calculateStochastic, calculateATR, calculateSupertrend, calculateEMA5x, calculateMA5x, calculateADX, calculateStochRSI, calculateStochRSI5x, calculateRSI5x)

        // Existing Signal Generation (unchanged)
        function generateSignal(klines, indicators, bbPeriod, bbStdDev, bbMargin, rsiPeriod, macdFast, macdSlow, macdSignal, kdjPeriod, kdjK, kdjD, sarStep, sarMaxStep, sarMargin, fibLevels, timeframe, marketType, candlePatterns, ichimokuTenkan, ichimokuKijun, ichimokuSenkouB, donchianPeriod, stochKPeriod, stochDPeriod, stochSmooth, supertrendPeriod, supertrendMultiplier, emaPeriods, maPeriods, adxPeriod, stochrsiPeriods, rsi5xPeriods) {
            // Existing signal generation logic
            // ... (unchanged, as provided in the original code)
        }

        // Fetch Initial Market Data (using REST API as fallback)
        async function fetchMarketData(marketType) {
            if (marketDataCache && Date.now() - cacheTimestamp < CACHE_DURATION) {
                return marketDataCache;
            }
            try {
                const data = await fetchWithRetry(`https://api.bybit.com/v5/market/tickers?category=${marketType}`);
                const filteredData = data.result.list.filter(ticker =>
                    ticker.symbol.endsWith('USDT') &&
                    parseFloat(ticker.turnover24h) >= parseFloat(document.getElementById('minVolume').value)
                );
                marketDataCache = filteredData;
                cacheTimestamp = Date.now();
                return filteredData;
            } catch (error) {
                console.error('Error fetching market data:', error);
                return [];
            }
        }

        async function fetchWithRetry(url, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    if (data.retCode !== 0) throw new Error(`API error: ${data.retMsg}`);
                    return data;
                } catch (error) {
                    if (i === retries - 1) throw error;
                    console.warn(`Retry ${i + 1}/${retries} for ${url}: ${error.message}`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Process Signals for a Symbol and Interval
        async function processSignal(symbol, interval, marketType, intervals) {
            const indicators = Array.from(document.getElementById('indicators').selectedOptions).map(opt => opt.value);
            const fibLevels = Array.from(document.getElementById('fibLevels').selectedOptions).map(opt => parseFloat(opt.value));
            const candlePatterns = Array.from(document.getElementById('candlePatterns').selectedOptions).map(opt => opt.value);
            const confirmTimeframes = Array.from(document.getElementById('confirmTimeframes').selectedOptions).map(opt => opt.value);
            const bbPeriod = parseInt(document.getElementById('bbPeriod').value);
            const bbStdDev = parseFloat(document.getElementById('bbStdDev').value);
            const bbMargin = parseFloat(document.getElementById('bbMargin').value);
            const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
            const macdFast = parseInt(document.getElementById('macdFast').value);
            const macdSlow = parseInt(document.getElementById('macdSlow').value);
            const macdSignal = parseInt(document.getElementById('macdSignal').value);
            const kdjPeriod = parseInt(document.getElementById('kdjPeriod').value);
            const kdjK = parseInt(document.getElementById('kdjK').value);
            const kdjD = parseInt(document.getElementById('kdjD').value);
            const sarStep = parseFloat(document.getElementById('sarStep').value);
            const sarMaxStep = parseFloat(document.getElementById('sarMaxStep').value);
            const sarMargin = parseFloat(document.getElementById('sarMargin').value);
            const ichimokuTenkan = parseInt(document.getElementById('ichimokuTenkan').value);
            const ichimokuKijun = parseInt(document.getElementById('ichimokuKijun').value);
            const ichimokuSenkouB = parseInt(document.getElementById('ichimokuSenkouB').value);
            const donchianPeriod = parseInt(document.getElementById('donchianPeriod').value);
            const stochKPeriod = parseInt(document.getElementById('stochKPeriod').value);
            const stochDPeriod = parseInt(document.getElementById('stochDPeriod').value);
            const stochSmooth = parseInt(document.getElementById('stochSmooth').value);
            const supertrendPeriod = parseInt(document.getElementById('supertrendPeriod').value);
            const supertrendMultiplier = parseFloat(document.getElementById('supertrendMultiplier').value);
            const emaPeriods = [
                parseInt(document.getElementById('ema1').value),
                parseInt(document.getElementById('ema2').value),
                parseInt(document.getElementById('ema3').value),
                parseInt(document.getElementById('ema4').value),
                parseInt(document.getElementById('ema5').value)
            ];
            const maPeriods = [
                parseInt(document.getElementById('ma1').value),
                parseInt(document.getElementById('ma2').value),
                parseInt(document.getElementById('ma3').value),
                parseInt(document.getElementById('ma4').value),
                parseInt(document.getElementById('ma5').value)
            ];
            const adxPeriod = parseInt(document.getElementById('adxPeriod').value);
            const stochrsiPeriods = [
                parseInt(document.getElementById('stochrsi1').value),
                parseInt(document.getElementById('stochrsi2').value),
                parseInt(document.getElementById('stochrsi3').value),
                parseInt(document.getElementById('stochrsi4').value),
                parseInt(document.getElementById('stochrsi5').value)
            ];
            const rsi5xPeriods = [
                parseInt(document.getElementById('rsi5x1').value),
                parseInt(document.getElementById('rsi5x2').value),
                parseInt(document.getElementById('rsi5x3').value),
                parseInt(document.getElementById('rsi5x4').value),
                parseInt(document.getElementById('rsi5x5').value)
            ];

            const klines = klineData.get(symbol)?.get(interval) || [];
            if (klines.length < 200) return; // Ensure enough data

            const signalData = generateSignal(
                klines, indicators, bbPeriod, bbStdDev, bbMargin, rsiPeriod,
                macdFast, macdSlow, macdSignal, kdjPeriod, kdjK, kdjD,
                sarStep, sarMaxStep, sarMargin, fibLevels, interval, marketType,
                candlePatterns, ichimokuTenkan, ichimokuKijun, ichimokuSenkouB,
                donchianPeriod, stochKPeriod, stochDPeriod, stochSmooth,
                supertrendPeriod, supertrendMultiplier, emaPeriods, maPeriods,
                adxPeriod, stochrsiPeriods, rsi5xPeriods
            );

            if (signalData) {
                let confirmed = true;
                for (const confirmInterval of confirmTimeframes) {
                    if (confirmInterval === interval) continue;
                    const confirmKlines = klineData.get(symbol)?.get(confirmInterval) || [];
                    if (confirmKlines.length < 200) {
                        confirmed = false;
                        break;
                    }
                    const confirmSignal = generateSignal(
                        confirmKlines, indicators, bbPeriod, bbStdDev, bbMargin, rsiPeriod,
                        macdFast, macdSlow, macdSignal, kdjPeriod, kdjK, kdjD,
                        sarStep, sarMaxStep, sarMargin, fibLevels, confirmInterval, marketType,
                        candlePatterns, ichimokuTenkan, ichimokuKijun, ichimokuSenkouB,
                        donchianPeriod, stochKPeriod, stochDPeriod, stochSmooth,
                        supertrendPeriod, supertrendMultiplier, emaPeriods, maPeriods,
                        adxPeriod, stochrsiPeriods, rsi5xPeriods
                    );
                    if (!confirmSignal || confirmSignal.signal !== signalData.signal) {
                        confirmed = false;
                        break;
                    }
                }

                if (confirmed) {
                    const resultsEl = document.getElementById('results');
                    resultsEl.prepend(renderSignalCard(signalData, symbol));
                    signalHistory.push({
                        time: Date.now(),
                        pair: symbol,
                        signal: signalData.signal,
                        price: signalData.currentPrice,
                        strength: signalData.strength,
                        timeframe: interval,
                        marketType,
                        activeIndicators: signalData.activeIndicators
                    });
                    updateStats();
                    renderHistory();
                }
            }
        }

        // Update Stats
        function updateStats() {
            const buySignals = signalHistory.filter(s => s.signal === 'BUY').length;
            const sellSignals = signalHistory.filter(s => s.signal === 'SELL').length;
            document.getElementById('stats').style.display = 'grid';
            document.getElementById('totalPairs').textContent = marketDataCache ? marketDataCache.length : 0;
            document.getElementById('buySignals').textContent = buySignals;
            document.getElementById('sellSignals').textContent = sellSignals;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        // Existing Render Functions (unchanged)
        function renderSignalCard(signalData, pair) {
            // Existing renderSignalCard logic
            // ... (unchanged, as provided in the original code)
        }

        function renderHistory() {
            // Existing renderHistory logic
            // ... (unchanged, as provided in the original code)
        }

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.style.display = 'block';
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.setAttribute('aria-live', 'polite');
        }

        // Start Scanning
        async function startScanning() {
            if (isScanning) return;
            isScanning = true;
            const startBtn = document.getElementById('startScanBtn');
            startBtn.disabled = true;
            startBtn.querySelector('#scanBtnText').textContent = 'Scanning...';
            startBtn.innerHTML += ' <span class="spinner"></span>';

            const indicators = Array.from(document.getElementById('indicators').selectedOptions).map(opt => opt.value);
            if (indicators.length === 0) {
                updateStatus('Please select at least one indicator.', 'error');
                stopScanning();
                return;
            }

            const marketType = document.getElementById('marketType').value;
            const intervals = Array.from(document.getElementById('intervals').selectedOptions).map(opt => opt.value);

            updateStatus('Initializing WebSocket connection...', 'loading');
            connectWebSocket(marketType, intervals);
        }

        // Stop Scanning
        function stopScanning() {
            isScanning = false;
            if (ws) ws.close();
            if (wsPingInterval) clearInterval(wsPingInterval);
            const startBtn = document.getElementById('startScanBtn');
            startBtn.disabled = false;
            startBtn.innerHTML = '<span id="scanBtnText">Start Scanning</span>';
            updateStatus('Scanning stopped.', 'info');
            updateWebSocketStatus('WebSocket: Disconnected', 'disconnected');
        }

        // Initialize history on page load
        renderHistory();
    </script>
</body>
</html>