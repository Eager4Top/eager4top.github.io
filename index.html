<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEXC Crypto BB Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .control-group input, .control-group select {
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 1rem;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(238, 90, 82, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: 500;
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
        }

        .status.success {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid rgba(40, 167, 69, 0.5);
        }

        .status.error {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid rgba(220, 53, 69, 0.5);
        }

        .results {
            display: grid;
            gap: 20px;
        }

        .signal-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .signal-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .signal-card.buy {
            border-left: 4px solid #28a745;
        }

        .signal-card.sell {
            border-left: 4px solid #dc3545;
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .pair-name {
            font-size: 1.4rem;
            font-weight: 700;
        }

        .signal-type {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .signal-type.buy {
            background: #28a745;
        }

        .signal-type.sell {
            background: #dc3545;
        }

        .signal-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .detail-item {
            text-align: center;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .detail-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .detail-value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .no-signals {
            text-align: center;
            padding: 40px;
            opacity: 0.7;
            font-size: 1.1rem;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Bybit Crypto BB Scanner</h1>
            <p>Real-time Bollinger Bands signals for cryptocurrency trading pairs</p>
        </div>

        <div class="controls">
            <div class="controls-grid">
                <div class="control-group">
                    <label for="bbPeriod">BB Period</label>
                    <input type="number" id="bbPeriod" value="20" min="5" max="50">
                </div>
                <div class="control-group">
                    <label for="bbStdDev">Standard Deviation</label>
                    <input type="number" id="bbStdDev" value="2" min="1" max="3" step="0.1">
                </div>
                <div class="control-group">
                    <label for="minVolume">Min 24h Volume (USDT)</label>
                    <input type="number" id="minVolume" value="100000" min="0">
                </div>
                <div class="control-group">
                    <label for="maxPairs">Max Pairs to Scan</label>
                    <input type="number" id="maxPairs" value="20" min="5" max="50">
                </div>
                <div class="control-group">
                    <button class="btn btn-primary" onclick="startScanning()">
                        <span id="scanBtnText">Start Scanning</span>
                    </button>
                </div>
                <div class="control-group">
                    <button class="btn btn-secondary" onclick="stopScanning()">Stop</button>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(40,167,69,0.1); border-radius: 8px; border: 1px solid rgba(40,167,69,0.3);">
                <small>
                    <strong>‚úÖ Bybit API:</strong> Direct access to real-time market data with no CORS restrictions. 
                    Enhanced with 200 candles for better signal accuracy and volume confirmation.
                </small>
            </div>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div class="stats" id="stats" style="display: none;">
            <div class="stat-card">
                <div class="stat-number" id="totalPairs">0</div>
                <div class="stat-label">Total Pairs</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="buySignals">0</div>
                <div class="stat-label">Buy Signals</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="sellSignals">0</div>
                <div class="stat-label">Sell Signals</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="lastUpdate">--:--</div>
                <div class="stat-label">Last Update</div>
            </div>
        </div>

        <div class="results" id="results"></div>
    </div>

    <script>
        let isScanning = false;
        let scanInterval = null;
        let allPairs = [];

        // Bollinger Bands calculation
        function calculateBB(prices, period = 20, stdDev = 2) {
            if (prices.length < period) return null;
            
            const sma = prices.slice(-period).reduce((sum, price) => sum + price, 0) / period;
            const variance = prices.slice(-period).reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
            const standardDeviation = Math.sqrt(variance);
            
            return {
                middle: sma,
                upper: sma + (standardDeviation * stdDev),
                lower: sma - (standardDeviation * stdDev)
            };
        }

        // Simple Moving Average calculation
        function calculateSMA(prices, period) {
            if (prices.length < period) return null;
            return prices.slice(-period).reduce((sum, price) => sum + price, 0) / period;
        }

        // Generate trading signal
        function generateSignal(klines, bbPeriod, bbStdDev) {
            if (klines.length < bbPeriod + 1) return null;

            const closes = klines.map(k => parseFloat(k[4])); // Close prices
            const volumes = klines.map(k => parseFloat(k[5])); // Volumes
            
            const currentBB = calculateBB(closes, bbPeriod, bbStdDev);
            const previousBB = calculateBB(closes.slice(0, -1), bbPeriod, bbStdDev);
            
            if (!currentBB || !previousBB) return null;

            const currentPrice = closes[closes.length - 1];
            const previousPrice = closes[closes.length - 2];
            const avgVolume = volumes.slice(-10).reduce((sum, vol) => sum + vol, 0) / 10;
            const currentVolume = volumes[volumes.length - 1];

            let signal = null;
            let strength = 0;

            // Enhanced Buy signal: Price touches or goes below lower band and bounces back
            if (previousPrice <= previousBB.lower && currentPrice > currentBB.lower) {
                signal = 'BUY';
                strength = Math.min(((currentBB.lower - previousPrice) / currentBB.lower) * 100, 5);
                
                // Boost strength if volume is above average
                if (currentVolume > avgVolume * 1.2) {
                    strength *= 1.3;
                }
            }
            // Enhanced Sell signal: Price touches or goes above upper band and falls back
            else if (previousPrice >= previousBB.upper && currentPrice < currentBB.upper) {
                signal = 'SELL';
                strength = Math.min(((previousPrice - currentBB.upper) / currentBB.upper) * 100, 5);
                
                // Boost strength if volume is above average
                if (currentVolume > avgVolume * 1.2) {
                    strength *= 1.3;
                }
            }
            // Additional signals for extreme situations
            else if (currentPrice <= currentBB.lower * 0.998) { // Strong oversold
                signal = 'BUY';
                strength = 4.5;
            }
            else if (currentPrice >= currentBB.upper * 1.002) { // Strong overbought
                signal = 'SELL';
                strength = 4.5;
            }

            if (signal) {
                return {
                    signal,
                    strength: Math.min(Math.max(strength, 1), 5), // Clamp between 1-5
                    currentPrice,
                    bb: currentBB,
                    volume: currentVolume,
                    avgVolume,
                    volumeRatio: currentVolume / avgVolume,
                    bandPosition: ((currentPrice - currentBB.lower) / (currentBB.upper - currentBB.lower)) * 100
                };
            }

            return null;
        }

        // Fetch market data from Bybit
        async function fetchMarketData() {
            try {
                const response = await fetch('https://api.bybit.com/v5/market/tickers?category=spot');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.retCode !== 0) {
                    throw new Error(`API error: ${data.retMsg}`);
                }
                
                return data.result.list.filter(ticker => 
                    ticker.symbol.endsWith('USDT') && 
                    parseFloat(ticker.turnover24h) >= parseFloat(document.getElementById('minVolume').value)
                );
            } catch (error) {
                console.error('Error fetching market data:', error);
                // Fallback with demo data if API fails
                return getDemoMarketData();
            }
        }

        // Fetch kline data for a specific pair from Bybit
        async function fetchKlineData(symbol) {
            try {
                const response = await fetch(`https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=60&limit=200`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.retCode !== 0) {
                    throw new Error(`API error: ${data.retMsg}`);
                }
                
                // Convert Bybit format to standard format
                return data.result.list.map(kline => [
                    parseInt(kline[0]), // timestamp
                    parseFloat(kline[1]), // open
                    parseFloat(kline[2]), // high
                    parseFloat(kline[3]), // low
                    parseFloat(kline[4]), // close
                    parseFloat(kline[5]), // volume
                    parseInt(kline[0]) + 3600000 // close time
                ]).reverse(); // Bybit returns newest first, we need oldest first
                
            } catch (error) {
                console.error(`Error fetching kline data for ${symbol}:`, error);
                // Generate demo kline data if API fails
                return generateDemoKlineData(symbol);
            }
        }

        // Demo market data for testing when API is unavailable
        function getDemoMarketData() {
            return [
                { symbol: 'BTCUSDT', turnover24h: '5000000', lastPrice: '43250.50' },
                { symbol: 'ETHUSDT', turnover24h: '3000000', lastPrice: '2650.75' },
                { symbol: 'SOLUSDT', turnover24h: '1200000', lastPrice: '98.45' },
                { symbol: 'BNBUSDT', turnover24h: '1500000', lastPrice: '315.20' },
                { symbol: 'XRPUSDT', turnover24h: '900000', lastPrice: '0.6150' },
                { symbol: 'ADAUSDT', turnover24h: '800000', lastPrice: '0.4850' },
                { symbol: 'DOTUSDT', turnover24h: '600000', lastPrice: '7.25' },
                { symbol: 'AVAXUSDT', turnover24h: '500000', lastPrice: '38.90' },
                { symbol: 'LINKUSDT', turnover24h: '400000', lastPrice: '14.85' },
                { symbol: 'MATICUSDT', turnover24h: '350000', lastPrice: '0.8950' }
            ];
        }

        // Generate demo kline data for testing
        function generateDemoKlineData(symbol) {
            const basePrice = getDemoMarketData().find(p => p.symbol === symbol)?.lastPrice || 100;
            const price = parseFloat(basePrice);
            const klines = [];
            
            for (let i = 199; i >= 0; i--) {
                const time = Date.now() - (i * 3600000); // 1 hour intervals
                const volatility = 0.02; // 2% volatility
                const trend = Math.sin(i / 20) * 0.01; // Add some trend
                const noise = (Math.random() - 0.5) * volatility;
                const priceChange = trend + noise;
                const currentPrice = price * (1 + priceChange * (i / 100));
                const volume = Math.random() * 1000000;
                
                // Create realistic OHLC data
                const open = currentPrice;
                const close = open * (1 + (Math.random() - 0.5) * 0.01);
                const high = Math.max(open, close) * (1 + Math.random() * 0.005);
                const low = Math.min(open, close) * (1 - Math.random() * 0.005);
                
                klines.push([
                    time,
                    open, // open
                    high, // high
                    low, // low
                    close, // close
                    volume, // volume
                    time + 3600000 // close time
                ]);
            }
            
            return klines;
        }

        // Update status message
        function updateStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }

        // Update statistics
        function updateStats(totalPairs, buySignals, sellSignals) {
            document.getElementById('totalPairs').textContent = totalPairs;
            document.getElementById('buySignals').textContent = buySignals;
            document.getElementById('sellSignals').textContent = sellSignals;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            document.getElementById('stats').style.display = 'grid';
        }

        // Display results
        function displayResults(signals) {
            const resultsEl = document.getElementById('results');
            
            if (signals.length === 0) {
                resultsEl.innerHTML = '<div class="no-signals">No trading signals found. Try adjusting your parameters.</div>';
                return;
            }

            const signalsHtml = signals.map(signal => `
                <div class="signal-card ${signal.signal.toLowerCase()}">
                    <div class="signal-header">
                        <div class="pair-name">${signal.symbol}</div>
                        <div class="signal-type ${signal.signal.toLowerCase()}">${signal.signal}</div>
                    </div>
                    <div class="signal-details">
                        <div class="detail-item">
                            <div class="detail-label">Current Price</div>
                            <div class="detail-value">$${signal.data.currentPrice.toFixed(6)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Upper Band</div>
                            <div class="detail-value">$${signal.data.bb.upper.toFixed(6)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Middle Band</div>
                            <div class="detail-value">$${signal.data.bb.middle.toFixed(6)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Lower Band</div>
                            <div class="detail-value">$${signal.data.bb.lower.toFixed(6)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Signal Strength</div>
                            <div class="detail-value">${signal.data.strength.toFixed(2)}/5</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Band Position</div>
                            <div class="detail-value">${signal.data.bandPosition.toFixed(1)}%</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Volume Ratio</div>
                            <div class="detail-value">${signal.data.volumeRatio.toFixed(2)}x</div>
                        </div>
                    </div>
                </div>
            `).join('');

            resultsEl.innerHTML = signalsHtml;
        }

        // Main scanning function
        async function scanPairs() {
            if (!isScanning) return;

            updateStatus('üîç Scanning market pairs...', 'loading');

            try {
                // Get market data
                const marketData = await fetchMarketData();
                const maxPairs = parseInt(document.getElementById('maxPairs').value);
                const topPairs = marketData
                    .sort((a, b) => parseFloat(b.turnover24h || b.quoteVolume || 0) - parseFloat(a.turnover24h || a.quoteVolume || 0))
                    .slice(0, maxPairs);

                updateStatus(`üìä Analyzing ${topPairs.length} pairs...`, 'loading');

                const bbPeriod = parseInt(document.getElementById('bbPeriod').value);
                const bbStdDev = parseFloat(document.getElementById('bbStdDev').value);
                const signals = [];

                // Process pairs in smaller batches to avoid rate limiting
                const batchSize = 3;
                for (let i = 0; i < topPairs.length; i += batchSize) {
                    if (!isScanning) break; // Allow stopping mid-scan
                    
                    const batch = topPairs.slice(i, i + batchSize);
                    const batchPromises = batch.map(async (pair) => {
                        try {
                            const klines = await fetchKlineData(pair.symbol);
                            if (klines && klines.length > 0) {
                                const signal = generateSignal(klines, bbPeriod, bbStdDev);
                                
                                if (signal) {
                                    return {
                                        symbol: pair.symbol,
                                        signal: signal.signal,
                                        data: signal
                                    };
                                }
                            }
                        } catch (error) {
                            console.error(`Error processing ${pair.symbol}:`, error);
                        }
                        return null;
                    });

                    const batchResults = await Promise.all(batchPromises);
                    signals.push(...batchResults.filter(result => result !== null));

                    // Update progress
                    const processed = Math.min(i + batchSize, topPairs.length);
                    updateStatus(`üìä Analyzed ${processed}/${topPairs.length} pairs... Found ${signals.length} signals`, 'loading');
                    
                    // Add delay between batches to respect rate limits
                    if (i + batchSize < topPairs.length) {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }

                // Sort signals by strength
                signals.sort((a, b) => b.data.strength - a.data.strength);

                const buySignals = signals.filter(s => s.signal === 'BUY').length;
                const sellSignals = signals.filter(s => s.signal === 'SELL').length;

                updateStats(topPairs.length, buySignals, sellSignals);
                displayResults(signals);

                if (signals.length > 0) {
                    updateStatus(`‚úÖ Found ${signals.length} trading signals!`, 'success');
                } else {
                    updateStatus('‚ÑπÔ∏è No signals detected. Market may be ranging.', 'success');
                }

            } catch (error) {
                console.error('Scanning error:', error);
                updateStatus('‚ùå Error occurred during scanning. Please try again.', 'error');
            }
        }

        // Start scanning
        function startScanning() {
            if (isScanning) return;
            
            isScanning = true;
            document.getElementById('scanBtnText').innerHTML = '<span class="spinner"></span> Scanning...';
            
            // Initial scan
            scanPairs();
            
            // Set up interval for continuous scanning (every 5 minutes)
            scanInterval = setInterval(scanPairs, 5 * 60 * 1000);
        }

        // Stop scanning
        function stopScanning() {
            isScanning = false;
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }
            document.getElementById('scanBtnText').textContent = 'Start Scanning';
            updateStatus('‚èπÔ∏è Scanning stopped.', 'success');
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Bybit Crypto BB Scanner initialized');
            updateStatus('üìä Ready to scan Bybit markets. Click "Start Scanning" to begin.', 'success');
        });
    </script>
</body>
</html>