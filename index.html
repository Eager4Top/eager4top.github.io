<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bybit Crypto BB Scanner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: start; /* Changed to start to align collapsible menu */
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .control-group input,
        .control-group select {
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 1rem;
        }

        .control-group select[multiple] {
            height: 120px;
            padding: 5px;
            overflow-y: auto;
        }

        .control-group select[multiple] option {
            padding: 5px;
        }

        .control-group select[multiple] option:checked {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        /* New styles for collapsible menu */
        details {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            padding: 5px;
            color: #fff;
        }

        details[open] summary {
            margin-bottom: 10px;
        }

        .bb-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(238, 90, 82, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: 500;
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
        }

        .status.success {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid rgba(40, 167, 69, 0.5);
        }

        .status.error {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid rgba(220, 53, 69, 0.5);
        }

        .results {
            display: grid;
            gap: 20px;
        }

        .signal-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .signal-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .signal-card.buy {
            border-left: 4px solid #28a745;
        }

        .signal-card.sell {
            border-left: 4px solid #dc3545;
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .pair-name {
            font-size: 1.4rem;
            font-weight: 700;
        }

        .signal-type {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .signal-type.buy {
            background: #28a745;
        }

        .signal-type.sell {
            background: #dc3545;
        }

        .signal-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .detail-item {
            text-align: center;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .detail-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .detail-value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .no-signals {
            text-align: center;
            padding: 40px;
            opacity: 0.7;
            font-size: 1.1rem;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .history-section {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .history-section h2 {
            font-size: 1.8rem;
            margin-bottom: 15px;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            overflow: hidden;
        }

        .history-table th,
        .history-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .history-table th {
            background: rgba(255,255,255,0.1);
            font-weight: 600;
        }

        .history-table tr:hover {
            background: rgba(255,255,255,0.1);
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" role="banner">
            <h1>🚀 Bybit Crypto BB Scanner</h1>
            <p>Real-time signals with customizable BB, RSI, MACD, KDJ, SAR, Fibonacci, Candlestick, and BB Squeeze for spot and futures markets</p>
        </div>

        <div class="controls" role="region" aria-label="Scanner controls">
            <div class="controls-grid">
                <!-- Indicator Selection -->
                <div class="control-group">
                    <label for="indicators">Select Indicators</label>
                    <select id="indicators" multiple aria-describedby="indicatorsDesc">
                        <option value="bb" selected>Bollinger Bands</option>
                        <option value="rsi" selected>RSI</option>
                        <option value="macd" selected>MACD</option>
                        <option value="kdj" selected>KDJ</option>
                        <option value="sar" selected>SAR</option>
                        <option value="fib" selected>Fibonacci</option>
                        <option value="candle" selected>Candlestick</option>
                        <option value="bbSqueeze" selected>BB Squeeze</option>
                    </select>
                    <small class="sr-only" id="indicatorsDesc">Select one or more indicators to use for signal generation (hold Ctrl/Cmd to select multiple)</small>
                </div>
                <!-- Fibonacci Levels Selection -->
                <div class="control-group">
                    <label for="fibLevels">Fibonacci Levels (%)</label>
                    <select id="fibLevels" multiple aria-describedby="fibLevelsDesc">
                        <option value="0" selected>0</option>
                        <option value="23.6" selected>23.6</option>
                        <option value="38.2" selected>38.2</option>
                        <option value="50" selected>50</option>
                        <option value="61.8" selected>61.8</option>
                        <option value="78.6" selected>78.6</option>
                        <option value="100" selected>100</option>
                        <option value="161.8">161.8</option>
                        <option value="261.8">261.8</option>
                        <option value="423.6">423.6</option>
                    </select>
                    <small id="fibLevelsDesc" class="sr-only">Select one or more Fibonacci retracement levels (hold Ctrl/Cmd to select multiple)</small>
                </div>
                <!-- Candlestick Patterns Selection -->
                <div class="control-group">
                    <label for="candlePatterns">Candlestick Patterns</label>
                    <select id="candlePatterns" multiple aria-describedby="candlePatternsDesc">
                        <option value="Doji" selected>Doji</option>
                        <option value="Hammer" selected>Hammer</option>
                        <option value="Hanging Man" selected>Hanging Man</option> <!-- NEW: Added Hanging Man -->
                        <option value="Bullish Engulfing" selected>Bullish Engulfing</option>
                        <option value="Bearish Engulfing" selected>Bearish Engulfing</option>
                        <option value="Morning Star" selected>Morning Star</option>
                        <option value="Evening Star" selected>Evening Star</option>
                    </select>
                    <small id="candlePatternsDesc" class="sr-only">Select one or more candlestick patterns to detect (hold Ctrl/Cmd to select multiple)</small>
                </div>
                <!-- Bollinger Bands Inputs (Collapsible Menu) -->
                <div class="control-group">
                    <details>
                        <summary>Bollinger Bands Parameters</summary>
                        <div class="bb-controls">
                            <div class="control-group">
                                <label for="bbPeriod">BB Period</label>
                                <input type="number" id="bbPeriod" value="20" min="5" max="50" aria-describedby="bbPeriodDesc">
                                <small id="bbPeriodDesc" class="sr-only">Bollinger Bands lookback period (5 to 50)</small>
                            </div>
                            <div class="control-group">
                                <label for="bbStdDev">BB Std Deviation</label>
                                <input type="number" id="bbStdDev" value="2" min="1" max="3" step="0.1" aria-describedby="bbStdDevDesc">
                                <small id="bbStdDevDesc" class="sr-only">Standard deviation multiplier for Bollinger Bands (1 to 3)</small>
                            </div>
                            <div class="control-group">
                                <label for="bbMargin">BB Margin (%)</label>
                                <input type="number" id="bbMargin" value="0.2" min="0" max="5" step="0.1" aria-describedby="bbMarginDesc">
                                <small id="bbMarginDesc" class="sr-only">Percentage margin around Bollinger Bands (0 to 5%)</small>
                            </div>
                        </div>
                    </details>
                </div>
                <!-- RSI Input -->
                <div class="control-group">
                    <label for="rsiPeriod">RSI Period</label>
                    <input type="number" id="rsiPeriod" value="14" min="5" max="30" aria-describedby="rsiPeriodDesc">
                    <small id="rsiPeriodDesc" class="sr-only">RSI lookback period (5 to 30)</small>
                </div>
                <!-- MACD Inputs -->
                <div class="control-group">
                    <label for="macdFast">MACD Fast Period</label>
                    <input type="number" id="macdFast" value="12" min="5" max="20" aria-describedby="macdFastDesc">
                    <small id="macdFastDesc" class="sr-only">MACD fast EMA period (5 to 20)</small>
                </div>
                <div class="control-group">
                    <label for="macdSlow">MACD Slow Period</label>
                    <input type="number" id="macdSlow" value="26" min="10" max="50" aria-describedby="macdSlowDesc">
                    <small id="macdSlowDesc" class="sr-only">MACD slow EMA period (10 to 50)</small>
                </div>
                <div class="control-group">
                    <label for="macdSignal">MACD Signal Period</label>
                    <input type="number" id="macdSignal" value="9" min="5" max="20" aria-describedby="macdSignalDesc">
                    <small id="macdSignalDesc" class="sr-only">MACD signal line period (5 to 20)</small>
                </div>
                <!-- KDJ Inputs -->
                <div class="control-group">
                    <label for="kdjPeriod">KDJ Period</label>
                    <input type="number" id="kdjPeriod" value="9" min="5" max="20" aria-describedby="kdjPeriodDesc">
                    <small id="kdjPeriodDesc" class="sr-only">KDJ lookback period (5 to 20)</small>
                </div>
                <div class="control-group">
                    <label for="kdjK">KDJ K Period</label>
                    <input type="number" id="kdjK" value="3" min="1" max="10" aria-describedby="kdjKDesc">
                    <small id="kdjKDesc" class="sr-only">KDJ K smoothing period (1 to 10)</small>
                </div>
                <div class="control-group">
                    <label for="kdjD">KDJ D Period</label>
                    <input type="number" id="kdjD" value="3" min="1" max="10" aria-describedby="kdjDDesc">
                    <small id="kdjDDesc" class="sr-only">KDJ D smoothing period (1 to 10)</small>
                </div>
                <!-- SAR Inputs -->
                <div class="control-group">
                    <label for="sarStep">SAR Step</label>
                    <input type="number" id="sarStep" value="0.02" min="0.01" max="0.1" step="0.01" aria-describedby="sarStepDesc">
                    <small id="sarStepDesc" class="sr-only">Parabolic SAR step (0.01 to 0.1)</small>
                </div>
                <div class="control-group">
                    <label for="sarMaxStep">SAR Max Step</label>
                    <input type="number" id="sarMaxStep" value="0.2" min="0.1" max="0.5" step="0.01" aria-describedby="sarMaxStepDesc">
                    <small id="sarMaxStepDesc" class="sr-only">Parabolic SAR max step (0.1 to 0.5)</small>
                </div>
                <div class="control-group">
                    <label for="sarMargin">SAR Margin (%)</label>
                    <input type="number" id="sarMargin" value="0.5" min="0" max="5" step="0.1" aria-describedby="sarMarginDesc">
                    <small id="sarMarginDesc" class="sr-only">Percentage margin around SAR (0 to 5%)</small>
                </div>
                <!-- Other Inputs -->
                <div class="control-group">
                    <label for="minVolume">Min 24h Volume (USDT)</label>
                    <input type="number" id="minVolume" value="100000" min="0" aria-describedby="minVolumeDesc">
                    <small id="minVolumeDesc" class="sr-only">Minimum 24-hour trading volume in USDT</small>
                </div>
                <div class="control-group">
                    <label for="marketType">Market Type</label>
                    <select id="marketType" aria-describedby="marketTypeDesc">
                        <option value="spot" selected>Spot</option>
                        <option value="linear">Futures</option>
                    </select>
                    <small id="marketTypeDesc" class="sr-only">Select market type (Spot or Futures)</small>
                </div>
                <!-- Modified: Changed interval to multi-select -->
                <div class="control-group">
                    <label for="intervals">Timeframes</label>
                    <select id="intervals" multiple aria-describedby="intervalsDesc">
                        <option value="15">15m</option>
                        <option value="60" selected>1h</option>
                        <option value="240">4h</option>
                        <option value="360">6h</option>
                        <option value="480">8h</option>
                        <option value="720">12h</option>
                        <option value="D">1d</option>
                        <option value="3D">3d</option>
                        <option value="W">1w</option>
                        <option value="M">1M</option>
                    </select>
                    <small id="intervalsDesc" class="sr-only">Select one or more timeframes for scanning (hold Ctrl/Cmd to select multiple)</small>
                </div>
                <div class="control-group">
                    <label for="confirmTimeframes">Confirm Timeframes</label>
                    <select id="confirmTimeframes" multiple aria-describedby="confirmTimeframesDesc">
                        <option value="15">15m</option>
                        <option value="60">1h</option>
                        <option value="240">4h</option>
                        <option value="360">6h</option>
                        <option value="480">8h</option>
                        <option value="720">12h</option>
                        <option value="D">1d</option>
                        <option value="3D">3d</option>
                        <option value="W">1w</option>
                        <option value="M">1M</option>
                    </select>
                    <small id="confirmTimeframesDesc" class="sr-only">Select additional timeframes for signal confirmation (hold Ctrl/Cmd to select multiple)</small>
                </div>
                <div class="control-group">
                    <button class="btn btn-primary" id="startScanBtn" onclick="startScanning()" aria-label="Start scanning for signals">
                        <span id="scanBtnText">Start Scanning</span>
                    </button>
                </div>
                <div class="control-group">
                    <button class="btn btn-secondary" onclick="stopScanning()" aria-label="Stop scanning">Stop</button>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(40,167,69,0.1); border-radius: 8px; border: 1px solid rgba(40,167,69,0.3);">
                <small>
                    <strong>✅ Bybit API:</strong> Scans all USDT pairs in spot and futures markets with customizable BB, RSI, MACD, KDJ, SAR, Fibonacci, Candlestick, and BB Squeeze signals across multiple timeframes.
                </small>
            </div>
        </div>

        <div id="status" class="status" role="alert" style="display: none;"></div>

        <div class="stats" id="stats" style="display: none;" role="region" aria-label="Scanning statistics">
            <div class="stat-card">
                <div class="stat-number" id="totalPairs">0</div>
                <div class="stat-label">Total Pairs</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="buySignals">0</div>
                <div class="stat-label">Buy Signals</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="sellSignals">0</div>
                <div class="stat-label">Sell Signals</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="lastUpdate">--:--</div>
                <div class="stat-label">Last Update</div>
            </div>
        </div>

        <div class="results" id="results" role="region" aria-label="Current trading signals"></div>

        <div class="history-section" id="history" role="region" aria-label="Historical trading signals">
            <h2>Signal History</h2>
            <table class="history-table">
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Pair</th>
                        <th>Signal</th>
                        <th>Price</th>
                        <th>Strength</th>
                        <th>Timeframe</th>
                        <th>Market</th>
                        <th>Indicators</th>
                    </tr>
                </thead>
                <tbody id="historyTableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        let isScanning = false;
        let scanInterval = null;
        let signalHistory = JSON.parse(localStorage.getItem('signalHistory')) || [];
        let marketDataCache = null;
        let cacheTimestamp = 0;
        const CACHE_DURATION = 60 * 1000;

        async function fetchWithRetry(url, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    if (data.retCode !== 0) throw new Error(`API error: ${data.retMsg}`);
                    return data;
                } catch (error) {
                    if (i === retries - 1) throw error;
                    console.warn(`Retry ${i + 1}/${retries} for ${url}: ${error.message}`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        function calculateBB(prices, period, stdDev, marginPercent) {
            if (prices.length < period) return null;
            const sma = prices.slice(-period).reduce((sum, price) => sum + price, 0) / period;
            const variance = prices.slice(-period).reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;
            const standardDeviation = Math.sqrt(variance);
            const margin = marginPercent / 100;
            return {
                middle: sma,
                upper: sma + (standardDeviation * stdDev) * (1 + margin),
                lower: sma - (standardDeviation * stdDev) * (1 + margin),
                bandwidth: (sma + (standardDeviation * stdDev) - (sma - (standardDeviation * stdDev))) / sma
            };
        }

        function calculateRSI(prices, period) {
            if (prices.length < period + 1) return null;
            let gains = 0, losses = 0;
            for (let i = 1; i <= period; i++) {
                const diff = prices[i] - prices[i - 1];
                if (diff >= 0) gains += diff;
                else losses -= diff;
            }
            const avgGain = gains / period;
            const avgLoss = losses / period;
            const rs = avgGain / (avgLoss || 1);
            return 100 - (100 / (1 + rs));
        }

        function calculateMACD(prices, fastPeriod, slowPeriod, signalPeriod) {
            if (prices.length < slowPeriod + signalPeriod) return null;
            const calculateEMA = (prices, period) => {
                const k = 2 / (period + 1);
                let ema = prices[0];
                for (let i = 1; i < prices.length; i++) {
                    ema = prices[i] * k + ema * (1 - k);
                }
                return ema;
            };
            const fastEMA = calculateEMA(prices.slice(-fastPeriod - signalPeriod), fastPeriod);
            const slowEMA = calculateEMA(prices.slice(-slowPeriod - signalPeriod), slowPeriod);
            const macd = fastEMA - slowEMA;
            const signalLine = calculateEMA(prices.slice(-signalPeriod).map((_, i) =>
                calculateEMA(prices.slice(-fastPeriod - signalPeriod + i, -signalPeriod + i), fastPeriod) -
                calculateEMA(prices.slice(-slowPeriod - signalPeriod + i, -signalPeriod + i), slowPeriod)
            ), signalPeriod);
            return { macd, signalLine, histogram: macd - signalLine };
        }

        function calculateKDJ(highs, lows, closes, period, kPeriod, dPeriod) {
            if (closes.length < period) return null;
            let kValues = [];
            for (let i = period - 1; i < closes.length; i++) {
                const high = Math.max(...highs.slice(i - period + 1, i + 1));
                const low = Math.min(...lows.slice(i - period + 1, i + 1));
                const close = closes[i];
                const k = ((close - low) / (high - low || 1)) * 100;
                kValues.push(k);
            }
            const k = kValues.slice(-kPeriod).reduce((sum, val) => sum + val, 0) / kPeriod;
            const d = kValues.slice(-dPeriod - kPeriod + 1, -kPeriod + 1).reduce((sum, val) => sum + val, 0) / dPeriod;
            const j = 3 * k - 2 * d;
            return { k, d, j };
        }

        function calculateSAR(highs, lows, closes, step, maxStep, marginPercent) {
            if (closes.length < 2) return null;
            let sar = lows[0], ep = highs[0], af = step, trend = 'up';
            const sars = [sar];
            const margin = 1 + marginPercent / 100;
            for (let i = 1; i < closes.length; i++) {
                if (trend === 'up') {
                    sar = sar + af * (ep - sar);
                    sar *= margin;
                    if (sar > lows[i]) {
                        trend = 'down';
                        sar = ep;
                        ep = lows[i];
                        af = step;
                    } else {
                        ep = Math.max(ep, highs[i]);
                        af = Math.min(af + step, maxStep);
                    }
                } else {
                    sar = sar + af * (ep - sar);
                    sar /= margin;
                    if (sar < highs[i]) {
                        trend = 'up';
                        sar = ep;
                        ep = highs[i];
                        af = step;
                    } else {
                        ep = Math.min(ep, lows[i]);
                        af = Math.min(af + step, maxStep);
                    }
                }
                sars.push(sar);
            }
            return sars[sars.length - 1];
        }

        function calculateFibonacci(highs, lows, levels) {
            if (highs.length < 2 || lows.length < 2) return null;
            const period = 20;
            const swingHigh = Math.max(...highs.slice(-period));
            const swingLow = Math.min(...lows.slice(-period));
            const range = swingHigh - swingLow;
            return levels.map(level => ({
                level: level,
                price: swingLow + (range * level / 100)
            }));
        }

        function detectCandlestickPatterns(klines, selectedPatterns) {
            if (klines.length < 3) return null;
            const [prev2, prev, curr] = klines.slice(-3);
            const open = parseFloat(curr[1]), high = parseFloat(curr[2]), low = parseFloat(curr[3]), close = parseFloat(curr[4]);
            const prevOpen = parseFloat(prev[1]), prevClose = parseFloat(prev[4]);
            const body = Math.abs(close - open);
            const upperShadow = high - Math.max(open, close);
            const lowerShadow = Math.min(open, close) - low;

            if (selectedPatterns.includes('Doji') && body <= (high - low) * 0.1 && upperShadow > body && lowerShadow > body) {
                return { pattern: 'Doji', signal: null };
            }
            if (selectedPatterns.includes('Hammer') && body <= (high - low) * 0.3 && lowerShadow > body * 2 && prevClose < prevOpen && close > open) {
                return { pattern: 'Hammer', signal: 'BUY' };
            }
            // NEW: Hanging Man pattern
            if (selectedPatterns.includes('Hanging Man') && body <= (high - low) * 0.3 && lowerShadow > body * 2 && prevClose > prevOpen && close < open) {
                return { pattern: 'Hanging Man', signal: 'SELL' };
            }
            if (selectedPatterns.includes('Bullish Engulfing') && prevClose < prevOpen && close > open && open < prevClose && close > prevOpen) {
                return { pattern: 'Bullish Engulfing', signal: 'BUY' };
            }
            if (selectedPatterns.includes('Bearish Engulfing') && prevClose > prevOpen && close < open && open > prevClose && close < prevOpen) {
                return { pattern: 'Bearish Engulfing', signal: 'SELL' };
            }
            if (selectedPatterns.includes('Morning Star') && klines.length >= 3 && prev2[4] < prev2[1] && Math.abs(prev[4] - prev[1]) < (prev[2] - prev[3]) * 0.3 && close > open && close > prev2[1]) {
                return { pattern: 'Morning Star', signal: 'BUY' };
            }
            if (selectedPatterns.includes('Evening Star') && klines.length >= 3 && prev2[4] > prev2[1] && Math.abs(prev[4] - prev[1]) < (prev[2] - prev[3]) * 0.3 && close < open && close < prev2[1]) {
                return { pattern: 'Evening Star', signal: 'SELL' };
            }
            return null;
        }

        function detectBBSqueeze(prices, period, stdDev, marginPercent) {
            if (prices.length < period + 1) return null;
            const bb = calculateBB(prices, period, stdDev, marginPercent);
            if (!bb) return null;
            const prevBB = calculateBB(prices.slice(0, -1), period, stdDev, marginPercent);
            if (!prevBB) return null;
            const isSqueeze = bb.bandwidth < 0.02;
            const currentPrice = prices[prices.length - 1];
            const previousPrice = prices[prices.length - 2];
            if (isSqueeze && prevBB.bandwidth < 0.02) {
                if (currentPrice > bb.upper && previousPrice <= prevBB.upper) {
                    return { pattern: 'BB Squeeze Breakout', signal: 'BUY' };
                } else if (currentPrice < bb.lower && previousPrice >= prevBB.lower) {
                    return { pattern: 'BB Squeeze Breakout', signal: 'SELL' };
                }
            }
            return null;
        }

        function generateSignal(klines, indicators, bbPeriod, bbStdDev, bbMargin, rsiPeriod, macdFast, macdSlow, macdSignal, kdjPeriod, kdjK, kdjD, sarStep, sarMaxStep, sarMargin, fibLevels, timeframe, marketType, candlePatterns) {
            if (klines.length < Math.max(bbPeriod, macdSlow + macdSignal, kdjPeriod, 20)) return null;
            const closes = klines.map(k => parseFloat(k[4]));
            const highs = klines.map(k => parseFloat(k[2]));
            const lows = klines.map(k => parseFloat(k[3]));
            const volumes = klines.map(k => parseFloat(k[5]));
            const currentPrice = closes[closes.length - 1];
            const previousPrice = closes[closes.length - 2];
            const avgVolume = volumes.slice(-10).reduce((sum, vol) => sum + vol, 0) / 10;
            const currentVolume = volumes[volumes.length - 1];

            const bb = indicators.includes('bb') || indicators.includes('bbSqueeze') ? calculateBB(closes, bbPeriod, bbStdDev, bbMargin) : null;
            const rsi = indicators.includes('rsi') ? calculateRSI(closes, rsiPeriod) : null;
            const macd = indicators.includes('macd') ? calculateMACD(closes, macdFast, macdSlow, macdSignal) : null;
            const kdj = indicators.includes('kdj') ? calculateKDJ(highs, lows, closes, kdjPeriod, kdjK, kdjD) : null;
            const sar = indicators.includes('sar') ? calculateSAR(highs, lows, closes, sarStep, sarMaxStep, sarMargin) : null;
            const fib = indicators.includes('fib') ? calculateFibonacci(highs, lows, fibLevels) : null;
            const candle = indicators.includes('candle') ? detectCandlestickPatterns(klines, candlePatterns) : null;
            const bbSqueeze = indicators.includes('bbSqueeze') ? detectBBSqueeze(closes, bbPeriod, bbStdDev, bbMargin) : null;

            let signal = null, strength = 0, activeIndicators = [];

            if (indicators.includes('bb') && bb) {
                if (previousPrice <= bb.lower && currentPrice > bb.lower) {
                    signal = 'BUY';
                    strength = Math.min(((bb.lower - previousPrice) / bb.lower) * 100, 5);
                    activeIndicators.push('BB');
                } else if (previousPrice >= bb.upper && currentPrice < bb.upper) {
                    signal = 'SELL';
                    strength = Math.min(((previousPrice - bb.upper) / bb.upper) * 100, 5);
                    activeIndicators.push('BB');
                }
            }

            if (indicators.includes('fib') && fib && !signal) {
                const nearestLevel = fib.reduce((closest, level) =>
                    Math.abs(currentPrice - level.price) < Math.abs(currentPrice - closest.price) ? level : closest
                );
                const distance = Math.abs(currentPrice - nearestLevel.price) / currentPrice;
                if (distance < 0.005) {
                    if (previousPrice < nearestLevel.price && currentPrice > nearestLevel.price) {
                        signal = 'BUY';
                        strength = Math.min(5 - distance * 1000, 5);
                        activeIndicators.push(`Fib ${nearestLevel.level}%`);
                    } else if (previousPrice > nearestLevel.price && currentPrice < nearestLevel.price) {
                        signal = 'SELL';
                        strength = Math.min(5 - distance * 1000, 5);
                        activeIndicators.push(`Fib ${nearestLevel.level}%`);
                    }
                }
            }

            if (indicators.includes('candle') && candle && !signal && candle.signal) {
                signal = candle.signal;
                strength = 3;
                activeIndicators.push(candle.pattern);
            }

            if (indicators.includes('bbSqueeze') && bbSqueeze && !signal) {
                signal = bbSqueeze.signal;
                strength = 3.5;
                activeIndicators.push(bbSqueeze.pattern);
            }

            if (!signal) return null;

            if (indicators.includes('rsi') && rsi) {
                if (signal === 'BUY' && rsi > 30 && rsi < 50) {
                    strength *= 1.2;
                    activeIndicators.push('RSI');
                } else if (signal === 'SELL' && rsi > 50 && rsi < 70) {
                    strength *= 1.2;
                    activeIndicators.push('RSI');
                } else if ((signal === 'BUY' && rsi >= 50) || (signal === 'SELL' && rsi <= 50)) {
                    strength *= 0.8;
                }
            }

            if (indicators.includes('macd') && macd) {
                if (signal === 'BUY' && macd.macd > macd.signalLine && macd.histogram > 0) {
                    strength *= 1.2;
                    activeIndicators.push('MACD');
                } else if (signal === 'SELL' && macd.macd < macd.signalLine && macd.histogram < 0) {
                    strength *= 1.2;
                    activeIndicators.push('MACD');
                } else if ((signal === 'BUY' && macd.macd <= macd.signalLine) || (signal === 'SELL' && macd.macd >= macd.signalLine)) {
                    strength *= 0.8;
                }
            }

            if (indicators.includes('kdj') && kdj) {
                if (signal === 'BUY' && kdj.k < 80 && kdj.j > kdj.d) {
                    strength *= 1.2;
                    activeIndicators.push('KDJ');
                } else if (signal === 'SELL' && kdj.k > 20 && kdj.j < kdj.d) {
                    strength *= 1.2;
                    activeIndicators.push('KDJ');
                } else if ((signal === 'BUY' && kdj.j <= kdj.d) || (signal === 'SELL' && kdj.j >= kdj.d)) {
                    strength *= 0.8;
                }
            }

            if (indicators.includes('sar') && sar) {
                if (signal === 'BUY' && currentPrice > sar) {
                    strength *= 1.2;
                    activeIndicators.push('SAR');
                } else if (signal === 'SELL' && currentPrice < sar) {
                    strength *= 1.2;
                    activeIndicators.push('SAR');
                } else if ((signal === 'BUY' && currentPrice <= sar) || (signal === 'SELL' && currentPrice >= sar)) {
                    strength *= 0.8;
                }
            }

            if (currentVolume > avgVolume * 1.2) {
                strength *= 1.3;
                activeIndicators.push('Volume');
            }

            return {
                signal,
                strength: Math.min(Math.max(strength, 1), 5),
                currentPrice,
                bb,
                rsi,
                macd,
                kdj,
                sar,
                fib: fib ? fib.map(f => ({ level: f.level, price: f.price })) : null,
                candle: candle ? candle.pattern : null,
                bbSqueeze: bbSqueeze ? bbSqueeze.pattern : null,
                volume: currentVolume,
                avgVolume,
                volumeRatio: currentVolume / avgVolume,
                bandPosition: bb ? ((currentPrice - bb.lower) / (bb.upper - bb.lower)) * 100 : null,
                timeframe,
                marketType,
                activeIndicators
            };
        }

        async function fetchMarketData(marketType) {
            if (marketDataCache && Date.now() - cacheTimestamp < CACHE_DURATION) {
                return marketDataCache;
            }
            const data = await fetchWithRetry(`https://api.bybit.com/v5/market/tickers?category=${marketType}`);
            const filteredData = data.result.list.filter(ticker =>
                ticker.symbol.endsWith('USDT') &&
                parseFloat(ticker.turnover24h) >= parseFloat(document.getElementById('minVolume').value)
            );
            marketDataCache = filteredData;
            cacheTimestamp = Date.now();
            return filteredData;
        }

        async function fetchKlineData(symbol, interval, marketType) {
            const data = await fetchWithRetry(`https://api.bybit.com/v5/market/kline?category=${marketType}&symbol=${symbol}&interval=${interval}&limit=200`);
            return data.result.list.map(kline => [
                parseInt(kline[0]),
                parseFloat(kline[1]),
                parseFloat(kline[2]),
                parseFloat(kline[3]),
                parseFloat(kline[4]),
                parseFloat(kline[5]),
                parseInt(kline[0]) + 3600000
            ]).reverse();
        }

        function updateStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }

        function updateStats(totalPairs, buySignals, sellSignals) {
            document.getElementById('totalPairs').textContent = totalPairs;
            document.getElementById('buySignals').textContent = buySignals;
            document.getElementById('sellSignals').textContent = sellSignals;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            document.getElementById('stats').style.display = 'grid';
        }

        function saveSignal(signal) {
            signalHistory.push({
                time: new Date().toLocaleString(),
                symbol: signal.symbol,
                signal: signal.signal,
                price: signal.data.currentPrice,
                strength: signal.data.strength,
                timeframe: signal.data.timeframe,
                marketType: signal.data.markeyType,
                indicators: signal.data.activeIndicators.join(', ')
            });
            if(signalHistory.length > 1000) signalHistory.shift();
            localStorage.setItem('signalHistory', JSON.stringify(signalHistory));
            updateHistoryTable();
        }

        function updateHistoryTable() {
            const tbody = document.getElementById('historyTableBody');
            tbody.innerHTML = signalHistory.map(signal => `
                <tr>
                    <td>${signal.time}</td>
                    <td>${signal.symbol}</td>
                    <td>${signal.signal}</td>
                    <td>$${signal.price.toFixed(6)}</td>
                    <td>${signal.strength.toFixed(2)}</td>
                    <td>${signal.timeframe}</td>
                    <td>${signal.marketType}</td>
                    <td>${signal.indicators}</td>
                </tr>
            `).join('');
        }

        function displayResults(signals) {
            const resultsEl = document.getElementById('results');
            if (signals.length === 0) {
                resultsEl.innerHTML = '<div class="no-signals">No trading signals found. Please try adjusting your parameters.</div>';
                return;
            }
            const signalsHtml = signals.map(signal => `
                <div class="signal-card ${signal.signal.toLowerCase()}" role="article" aria-label="Trading signal for ${signal.symbol}">
                    <div class="signal-header">
                        <div class="pair-name">${signal.symbol}</div>
                        <div class="signal-type ${signal.signal.toLowerCase()}">${signal.signal}</div>
                    </div>
                    <div class="signal-details">
                        <div class="detail-item">
                            <div class="detail-label">Current Price</div>
                            <div class="detail-value">$${signal.data.currentPrice.toFixed(6)}</div>
                        </div>
                        ${signal.data.bb ? `
                        <div class="detail-item">
                            <div class="detail-label">Upper Band</div>
                            <div class="detail-value">$${signal.data.bb.upper.toFixed(6)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Middle Band</div>
                            <div class="detail-value">$${signal.data.bb.middle.toFixed(6)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Lower Band</div>
                            <div class="detail-value">$${signal.data.bb.lower.toFixed(6)}</div>
                        </div>
                        ` : ''}
                        ${signal.data.rsi ? `
                        <div class="detail-item">
                            <div class="detail-label">RSI</div>
                            <div class="detail-value">${signal.data.rsi.toFixed(2)}</div>
                        </div>
                        ` : ''}
                        ${signal.data.macd ? `
                        <div class="detail-item">
                            <div class="detail-label">MACD Histogram</div>
                            <div class="detail-value">${signal.data.macd.histogram.toFixed(4)}</div>
                        </div>
                        ` : ''}
                        ${signal.data.kdj ? `
                        <div class="detail-item">
                            <div class="detail-label">KDJ (K/D/J)</div>
                            <div class="detail-value">${signal.data.kdj.k.toFixed(2)}/${signal.data.kdj.d.toFixed(2)}/${signal.data.kdj.j.toFixed(2)}</div>
                        </div>
                        ` : ''}
                        ${signal.data.sar ? `
                        <div class="detail-item">
                            <div class="detail-label">SAR</div>
                            <div class="detail-value">$${signal.data.sar.toFixed(6)}</div>
                        </div>
                        ` : ''}
                        ${signal.data.fib ? `
                        <div class="detail-item">
                            <div class="detail-label">Nearest Fib Level</div>
                            <div class="detail-value">${signal.data.fib.reduce((closest, f) =>
                                Math.abs(signal.data.currentPrice - f.price) < Math.abs(signal.data.currentPrice - closest.price) ? f : closest
                            ).level}%</div>
                        </div>
                        ` : ''}
                        ${signal.data.candle ? `
                        <div class="detail-item">
                            <div class="detail-label">Candlestick Pattern</div>
                            <div class="detail-value">${signal.data.candle}</div>
                        </div>
                        ` : ''}
                        ${signal.data.bbSqueeze ? `
                        <div class="detail-item">
                            <div class="detail-label">BB Squeeze</div>
                            <div class="detail-value">${signal.data.bbSqueeze}</div>
                        </div>
                        ` : ''}
                        <div class="detail-item">
                            <div class="detail-label">Signal Strength</div>
                            <div class="detail-value">${signal.data.strength.toFixed(2)}/5</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Band Position</div>
                            <div class="detail-value">${signal.data.bandPosition ? signal.data.bandPosition.toFixed(1) + '%' : 'N/A'}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Volume Ratio</div>
                            <div class="detail-value">${signal.data.volumeRatio.toFixed(2)}x</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Timeframe</div>
                            <div class="detail-value">${signal.data.timeframe}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Market</div>
                            <div class="detail-value">${signal.data.marketType}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Indicators Used</div>
                            <div class="detail-value">${signal.data.activeIndicators.join(', ')}</div>
                        </div>
                    </div>
                </div>
            `).join('');
            resultsEl.innerHTML = signalsHtml;
        }

        async function scanPairs() {
            if (!isScanning) return;
            updateStatus('🔍 Scanning market pairs...', 'loading');
            try {
                const marketType = document.getElementById('marketType').value;
                const marketData = await fetchMarketData(marketType);
                // Modified: Use all USDT pairs (no maxPairs limit)
                const topPairs = marketData.sort((a, b) => parseFloat(b.turnover24h) - parseFloat(a.turnover24h));
                updateStatus(`📊 Analyzing ${topPairs.length} pairs in ${marketType} market...`, 'loading');

                const indicators = Array.from(document.getElementById('indicators').selectedOptions).map(opt => opt.value);
                if (indicators.length === 0) {
                    updateStatus('❌ Please select at least one indicator.', 'error');
                    stopScanning();
                    return;
                }
                const fibLevels = Array.from(document.getElementById('fibLevels').selectedOptions).map(opt => parseFloat(opt.value)).filter(n => !isNaN(n));
                const candlePatterns = Array.from(document.getElementById('candlePatterns').selectedOptions).map(opt => opt.value);
                const bbPeriod = parseInt(document.getElementById('bbPeriod').value);
                const bbStdDev = parseFloat(document.getElementById('bbStdDev').value);
                const bbMargin = parseFloat(document.getElementById('bbMargin').value);
                const rsiPeriod = parseInt(document.getElementById('rsiPeriod').value);
                const macdFast = parseInt(document.getElementById('macdFast').value);
                const macdSlow = parseInt(document.getElementById('macdSlow').value);
                const macdSignal = parseInt(document.getElementById('macdSignal').value);
                const kdjPeriod = parseInt(document.getElementById('kdjPeriod').value);
                const kdjK = parseInt(document.getElementById('kdjK').value);
                const kdjD = parseInt(document.getElementById('kdjD').value);
                const sarStep = parseFloat(document.getElementById('sarStep').value);
                const sarMaxStep = parseFloat(document.getElementById('sarMaxStep').value);
                const sarMargin = parseFloat(document.getElementById('sarMargin').value);
                // Modified: Get multiple intervals
                const intervals = Array.from(document.getElementById('intervals').selectedOptions).map(opt => opt.value);
                if (intervals.length === 0) {
                    updateStatus('❌ Please select at least one timeframe.', 'error');
                    stopScanning();
                    return;
                }
                const confirmTimeframes = Array.from(document.getElementById('confirmTimeframes').selectedOptions).map(opt => opt.value);
                const signals = [];

                // Modified: Iterate over each selected interval
                for (const interval of intervals) {
                    updateStatus(`📊 Analyzing ${topPairs.length} pairs in ${marketType} market on ${interval} timeframe...`, 'loading');
                    const batchPromises = topPairs.map(async pair => {
                        try {
                            const klines = await fetchKlineData(pair.symbol, interval, marketType);
                            if (klines && klines.length > 0) {
                                const signal = generateSignal(
                                    klines, indicators, bbPeriod, bbStdDev, bbMargin, rsiPeriod,
                                    macdFast, macdSlow, macdSignal, kdjPeriod, kdjK, kdjD,
                                    sarStep, sarMaxStep, sarMargin, fibLevels, interval, marketType, candlePatterns
                                );
                                if (signal && confirmTimeframes.length > 0) {
                                    let confirmations = 0;
                                    const confirmPromises = confirmTimeframes.map(async tf => {
                                        try {
                                            const confirmKlines = await fetchKlineData(pair.symbol, tf, marketType);
                                            const confirmSignal = generateSignal(
                                                confirmKlines, indicators, bbPeriod, bbStdDev, bbMargin, rsiPeriod,
                                                macdFast, macdSlow, macdSignal, kdjPeriod, kdjK, kdjD,
                                                sarStep, sarMaxStep, sarMargin, fibLevels, tf, marketType, candlePatterns
                                            );
                                            if (confirmSignal && confirmSignal.signal === signal.signal) {
                                                confirmations++;
                                            }
                                        } catch (error) {
                                            console.error(`Error confirming ${pair.symbol} on ${tf}:`, error);
                                        }
                                    });
                                    await Promise.allSettled(confirmPromises);
                                    signal.strength *= (1 + 0.2 * confirmations);
                                    if (confirmations >= confirmTimeframes.length / 2) {
                                        return { symbol: pair.symbol, signal: signal.signal, data: signal };
                                    }
                                } else if (signal) {
                                    return { symbol: pair.symbol, signal: signal.signal, data: signal };
                                }
                            }
                        } catch (error) {
                            console.error(`Error processing ${pair.symbol} on ${interval}:`, error);
                        }
                        return null;
                    });

                    const batchResults = await Promise.allSettled(batchPromises);
                    signals.push(...batchResults
                        .filter(result => result.status === 'fulfilled' && result.value !== null)
                        .map(result => result.value));
                }

                signals.forEach(saveSignal);

                signals.sort((a, b) => b.data.strength - a.data.strength);
                const buySignals = signals.filter(s => s.signal === 'BUY').length;
                const sellSignals = signals.filter(s => s.signal === 'SELL').length;

                updateStats(topPairs.length, buySignals, sellSignals);
                displayResults(signals);

                if (signals.length > 0) {
                    updateStatus(`✅ Found ${signals.length} trading signals in ${marketType} market across ${intervals.length} timeframes!`, 'success');
                } else {
                    updateStatus(`ℹ️ No signals detected in ${marketType} market. Market may be ranging.`, 'success');
                }
            } catch (error) {
                console.error('Scanning error:', error);
                updateStatus('❌ Error occurred during scanning. Please try again.', 'error');
            }
        }

        function startScanning() {
            if (isScanning) return;
            isScanning = true;
            document.getElementById('scanBtnText').innerHTML = '<span class="spinner"></span> Scanning...';
            scanPairs();
            // Modified: Use the shortest selected interval for scan frequency
            const intervals = Array.from(document.getElementById('intervals').selectedOptions).map(opt => opt.value);
            const intervalMs = Math.min(...intervals.map(interval =>
                interval === 'M' ? 30 * 24 * 60 * 60 * 1000 :
                interval === 'W' ? 7 * 24 * 60 * 60 * 1000 :
                interval === '3D' ? 3 * 24 * 60 * 60 * 1000 :
                interval === 'D' ? 24 * 60 * 60 * 1000 :
                parseInt(interval) * 60 * 1000
            ));
            scanInterval = setInterval(scanPairs, intervalMs);
        }

        function stopScanning() {
            isScanning = false;
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }
            document.getElementById('scanBtnText').textContent = 'Start Scanning';
            updateStatus('⏹️ Scanning stopped.', 'success');
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && document.activeElement.tagName === 'BUTTON') {
                document.activeElement.click();
            }
            if (event.key === 'Escape') {
                stopScanning();
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            console.log('Bybit Crypto BB Scanner initialized');
            updateStatus('📊 Ready to scan Bybit markets. Click "Start Scanning" to begin.', 'success');
            updateHistoryTable();
            document.getElementById('startScanBtn').focus();
        });
    </script>
</body>
</html>